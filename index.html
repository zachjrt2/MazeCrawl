<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MazeCrawl: Twitch Trials</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="./tmi.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
    }
    #root {
      width: 100%;
      min-height: 100vh;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script>
    const { useState, useEffect, useRef } = React;

    function generateMaze(gridSize) {
      const mazeWidth = gridSize * 2 + 1;
      const mazeHeight = gridSize * 2 + 1;
      const maze = Array.from({ length: mazeHeight }, () => Array(mazeWidth).fill(1));

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function carve(x, y) {
        const cellRow = y * 2 + 1;
        const cellCol = x * 2 + 1;
        maze[cellRow][cellCol] = 0;

        const directions = shuffle([
          { dx: 0, dy: -1 },
          { dx: 1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: -1, dy: 0 }
        ]);

        for (const dir of directions) {
          const newX = x + dir.dx;
          const newY = y + dir.dy;
          const newCellRow = newY * 2 + 1;
          const newCellCol = newX * 2 + 1;

          if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize && 
              maze[newCellRow][newCellCol] === 1) {
            const wallRow = cellRow + dir.dy;
            const wallCol = cellCol + dir.dx;
            maze[wallRow][wallCol] = 0;
            carve(newX, newY);
          }
        }
      }

      carve(0, 0);
      return { maze, gridSize, mazeWidth, mazeHeight };
    }

    const Trophy = ({ size = 20, color = "currentColor" }) => 
      React.createElement('svg', { width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: color, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
        React.createElement('path', { d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6" }),
        React.createElement('path', { d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18" }),
        React.createElement('path', { d: "M4 22h16" }),
        React.createElement('path', { d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" }),
        React.createElement('path', { d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" }),
        React.createElement('path', { d: "M18 2H6v7a6 6 0 0 0 12 0V2Z" })
      );

    const Gamepad2 = ({ size = 20, color = "currentColor" }) =>
      React.createElement('svg', { width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: color, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
        React.createElement('line', { x1: "6", y1: "11", x2: "10", y2: "11" }),
        React.createElement('line', { x1: "8", y1: "9", x2: "8", y2: "13" }),
        React.createElement('line', { x1: "15", y1: "12", x2: "15.01", y2: "12" }),
        React.createElement('line', { x1: "18", y1: "10", x2: "18.01", y2: "10" }),
        React.createElement('path', { d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z" })
      );

    const Zap = ({ size = 20, color = "currentColor" }) =>
      React.createElement('svg', { width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: color, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
        React.createElement('polygon', { points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2" })
      );

    const Users = ({ size = 20, color = "currentColor" }) =>
      React.createElement('svg', { width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: color, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
        React.createElement('path', { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }),
        React.createElement('circle', { cx: "9", cy: "7", r: "4" }),
        React.createElement('path', { d: "M22 21v-2a4 4 0 0 0-3-3.87" }),
        React.createElement('path', { d: "M16 3.13a4 4 0 0 1 0 7.75" })
      );

    function MazeCrawl() {
      const [level, setLevel] = useState(1);
      const [startLevel, setStartLevel] = useState(1);
      const [gridSize, setGridSize] = useState(8);
      const [mazeData, setMazeData] = useState(null);
      const [playerPos, setPlayerPos] = useState({ x: 1, y: 1 });
      const [moveQueue, setMoveQueue] = useState([]);
      const [recentCommands, setRecentCommands] = useState([]);
      const [connected, setConnected] = useState(false);
      const [channel, setChannel] = useState('the_aia');
      const [status, setStatus] = useState('');
      const [highestLevel, setHighestLevel] = useState(1);
      
      const twitchClientRef = useRef(null);
      const gameLoopRef = useRef(null);

      useEffect(() => {
        const newMazeData = generateMaze(gridSize);
        setMazeData(newMazeData);
        setPlayerPos({ x: 1, y: 1 });
      }, [gridSize]);

      const connectToTwitch = async () => {
        if (!channel.trim()) {
          setStatus('Please enter a channel name');
          return;
        }

        try {
          if (!window.tmi) {
            setStatus('Error: tmi.js not loaded yet. Try reloading the page.');
            return;
          }

          if (twitchClientRef.current) {
            await twitchClientRef.current.disconnect();
          }

          const client = new window.tmi.Client({
            channels: [channel.toLowerCase()]
          });

          client.on('message', (ch, tags, message, self) => {
            handleTwitchMessage(tags.username, message);
          });

          await client.connect();
          twitchClientRef.current = client;
          setConnected(true);
          
          const validLevel = Math.max(1, Math.min(100, parseInt(startLevel) || 1));
          setLevel(validLevel);
          setHighestLevel(validLevel);
          setGridSize(8 + validLevel - 1);
          
          setStatus(`Connected to #${channel} - Starting at Level ${validLevel}`);
        } catch (error) {
          setStatus(`Connection failed: ${error.message}`);
        }
      };

      const handleTwitchMessage = (username, message) => {
        const cmd = message.trim().toLowerCase()[0];
        const validMoves = { w: 'up', a: 'left', s: 'down', d: 'right' };
        
        if (validMoves[cmd]) {
          setMoveQueue(prev => [...prev, cmd]);
          setRecentCommands(prev => [
            { username, cmd: validMoves[cmd], time: Date.now() },
            ...prev.slice(0, 4)
          ]);
        }
      };

      useEffect(() => {
        if (!connected || !mazeData) return;

        const processingRef = { current: false };

        gameLoopRef.current = setInterval(() => {
          if (processingRef.current) return;
          
          setMoveQueue(prev => {
            if (prev.length === 0) return prev;
            
            processingRef.current = true;
            const [nextMove, ...rest] = prev;
            
            setPlayerPos(currentPos => {
              let newX = currentPos.x;
              let newY = currentPos.y;
              
              switch (nextMove) {
                case 'w': newY = currentPos.y - 1; break;
                case 's': newY = currentPos.y + 1; break;
                case 'a': newX = currentPos.x - 1; break;
                case 'd': newX = currentPos.x + 1; break;
              }
              
              if (newX < 1 || newX >= mazeData.mazeWidth - 1 || newY < 1 || newY >= mazeData.mazeHeight - 1) {
                processingRef.current = false;
                return currentPos;
              }
              
              if (mazeData.maze[newY][newX] === 0) {
                if (newX === mazeData.mazeWidth - 2 && newY === mazeData.mazeHeight - 2) {
                  setTimeout(() => {
                    const newLevel = level + 1;
                    setLevel(newLevel);
                    setHighestLevel(prev => Math.max(prev, newLevel));
                    setGridSize(8 + newLevel - 1);
                    setMoveQueue([]);
                  }, 100);
                }
                processingRef.current = false;
                return { x: newX, y: newY };
              }
              
              processingRef.current = false;
              return currentPos;
            });
            
            return rest;
          });
        }, 250);

        return () => {
          if (gameLoopRef.current) clearInterval(gameLoopRef.current);
        };
      }, [connected, mazeData, level, gridSize]);

      const getNeonColor = () => {
        const colors = ['#00ffff', '#00ff88', '#ff00ff', '#ffff00', '#ff0088'];
        return colors[(level - 1) % colors.length];
      };

      if (!mazeData) return null;

      const cellSize = Math.min(600 / mazeData.mazeWidth, 40);

      return React.createElement('div', {
        style: {
          background: 'radial-gradient(circle at center, #020212 0%, #000 100%)',
          minHeight: '100vh',
          color: '#fff',
          fontFamily: "'Orbitron', monospace",
          padding: '20px',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center'
        }
      },
        React.createElement('div', { style: { textAlign: 'center', marginBottom: '20px' } },
          React.createElement('h1', {
            style: {
              fontSize: '2.5rem',
              margin: '0',
              textShadow: `0 0 20px ${getNeonColor()}`,
              color: getNeonColor()
            }
          }, 'MazeCrawl: Twitch Trials')
        ),

        !connected && React.createElement('div', {
          style: {
            background: 'rgba(10, 10, 30, 0.8)',
            border: `2px solid ${getNeonColor()}`,
            borderRadius: '10px',
            padding: '20px',
            marginBottom: '20px',
            boxShadow: `0 0 20px ${getNeonColor()}33`
          }
        },
          React.createElement('div', { style: { marginBottom: '15px' } },
            React.createElement('input', {
              type: 'text',
              value: channel,
              onChange: (e) => setChannel(e.target.value),
              placeholder: 'Twitch channel name',
              style: {
                background: '#0a0a1a',
                border: '1px solid #333',
                color: '#fff',
                padding: '10px',
                borderRadius: '5px',
                marginRight: '10px',
                fontSize: '1rem',
                width: '200px'
              }
            }),
            React.createElement('input', {
              type: 'number',
              value: startLevel,
              onChange: (e) => setStartLevel(Math.max(1, Math.min(100, parseInt(e.target.value) || 1))),
              placeholder: 'Start Level',
              min: '1',
              max: '100',
              style: {
                background: '#0a0a1a',
                border: '1px solid #333',
                color: '#fff',
                padding: '10px',
                borderRadius: '5px',
                fontSize: '1rem',
                width: '100px'
              }
            })
          ),
          React.createElement('button', {
            onClick: connectToTwitch,
            style: {
              background: getNeonColor(),
              color: '#000',
              border: 'none',
              padding: '10px 20px',
              borderRadius: '5px',
              fontWeight: 'bold',
              cursor: 'pointer',
              fontSize: '1rem'
            }
          }, 'Connect to Twitch'),
          status && React.createElement('div', {
            style: { marginTop: '10px', fontSize: '0.9rem' }
          }, status)
        ),

        connected && React.createElement('div', {
          style: {
            display: 'flex',
            gap: '20px',
            marginBottom: '20px',
            flexWrap: 'wrap',
            justifyContent: 'center'
          }
        },
          React.createElement('div', {
            style: {
              background: 'rgba(10, 10, 30, 0.8)',
              border: '1px solid #333',
              padding: '10px 20px',
              borderRadius: '5px',
              display: 'flex',
              alignItems: 'center',
              gap: '10px'
            }
          },
            React.createElement(Trophy, { size: 20, color: getNeonColor() }),
            React.createElement('span', null, 'Level: ', React.createElement('strong', null, level))
          ),
          React.createElement('div', {
            style: {
              background: 'rgba(10, 10, 30, 0.8)',
              border: '1px solid #333',
              padding: '10px 20px',
              borderRadius: '5px',
              display: 'flex',
              alignItems: 'center',
              gap: '10px'
            }
          },
            React.createElement(Gamepad2, { size: 20, color: getNeonColor() }),
            React.createElement('span', null, 'Size: ', React.createElement('strong', null, `${gridSize}×${gridSize}`))
          ),
          React.createElement('div', {
            style: {
              background: 'rgba(10, 10, 30, 0.8)',
              border: '1px solid #333',
              padding: '10px 20px',
              borderRadius: '5px',
              display: 'flex',
              alignItems: 'center',
              gap: '10px'
            }
          },
            React.createElement(Zap, { size: 20, color: getNeonColor() }),
            React.createElement('span', null, 'Queue: ', React.createElement('strong', null, moveQueue.length))
          ),
          React.createElement('div', {
            style: {
              background: 'rgba(10, 10, 30, 0.8)',
              border: '1px solid #333',
              padding: '10px 20px',
              borderRadius: '5px',
              display: 'flex',
              alignItems: 'center',
              gap: '10px'
            }
          },
            React.createElement(Users, { size: 20, color: getNeonColor() }),
            React.createElement('span', null, 'High Score: ', React.createElement('strong', null, highestLevel))
          )
        ),

        connected && React.createElement('div', {
          style: { display: 'flex', gap: '20px', flexWrap: 'wrap', justifyContent: 'center' }
        },
          React.createElement('div', {
            style: {
              display: 'grid',
              gridTemplateColumns: `repeat(${mazeData.mazeWidth}, ${cellSize}px)`,
              gridTemplateRows: `repeat(${mazeData.mazeHeight}, ${cellSize}px)`,
              gap: '0px',
              background: '#000',
              padding: '2px',
              borderRadius: '5px',
              filter: `drop-shadow(0 0 10px ${getNeonColor()})`,
            }
          },
            mazeData.maze.map((row, mazeY) =>
              row.map((cell, mazeX) => {
                const isPlayerCell = mazeX === playerPos.x && mazeY === playerPos.y;
                const isExit = mazeX === mazeData.mazeWidth - 2 && mazeY === mazeData.mazeHeight - 2;
                const isStart = mazeX === 1 && mazeY === 1;
                
                return React.createElement('div', {
                  key: `${mazeX}-${mazeY}`,
                  style: {
                    width: cellSize,
                    height: cellSize,
                    background: isPlayerCell ? getNeonColor() :
                               isExit ? '#ff0088' :
                               isStart ? '#00ff88' :
                               cell === 0 ? '#1a1a3a' : '#0a0a1a',
                    boxShadow: isPlayerCell ? `0 0 20px ${getNeonColor()}` :
                               isExit ? '0 0 15px #ff0088' :
                               isStart ? '0 0 10px #00ff88' :
                               cell === 0 ? 'inset 0 0 3px rgba(100,100,255,0.3)' : 'none',
                    transition: 'all 0.15s ease',
                    borderRadius: cell === 0 ? '1px' : '0px'
                  }
                });
              })
            )
          ),

          React.createElement('div', {
            style: {
              background: 'rgba(10, 10, 30, 0.8)',
              border: '1px solid #333',
              borderRadius: '10px',
              padding: '15px',
              minWidth: '200px',
              maxWidth: '300px'
            }
          },
            React.createElement('h3', {
              style: { margin: '0 0 10px 0', fontSize: '1rem', color: getNeonColor() }
            }, 'Recent Commands'),
            React.createElement('div', { style: { fontSize: '0.85rem' } },
              recentCommands.length === 0 ?
                React.createElement('div', { style: { color: '#666' } }, 'Waiting for chat input...') :
                recentCommands.map((cmd, i) =>
                  React.createElement('div', {
                    key: cmd.time,
                    style: {
                      padding: '5px',
                      background: 'rgba(0,255,255,0.1)',
                      marginBottom: '5px',
                      borderRadius: '3px',
                      border: '1px solid #333',
                      opacity: 1 - (i * 0.15)
                    }
                  },
                    React.createElement('strong', { style: { color: getNeonColor() } }, cmd.username + ':'),
                    ' ' + cmd.cmd
                  )
                )
            ),
            React.createElement('div', {
              style: {
                marginTop: '15px',
                padding: '10px',
                background: 'rgba(0,0,0,0.5)',
                borderRadius: '5px',
                fontSize: '0.8rem'
              }
            },
              React.createElement('div', { style: { marginBottom: '5px', color: getNeonColor() } }, 'Chat Commands:'),
              React.createElement('div', null, '• ', React.createElement('strong', null, 'w'), ' = Up'),
              React.createElement('div', null, '• ', React.createElement('strong', null, 'a'), ' = Left'),
              React.createElement('div', null, '• ', React.createElement('strong', null, 's'), ' = Down'),
              React.createElement('div', null, '• ', React.createElement('strong', null, 'd'), ' = Right')
            )
          )
        ),

        !connected && React.createElement('div', {
          style: {
            marginTop: '20px',
            padding: '20px',
            background: 'rgba(10, 10, 30, 0.5)',
            borderRadius: '10px',
            maxWidth: '600px',
            fontSize: '0.9rem',
            lineHeight: '1.6'
          }
        },
          React.createElement('h3', { style: { color: getNeonColor(), marginTop: 0 } }, 'How to Play:'),
          React.createElement('ul', { style: { paddingLeft: '20px' } },
            React.createElement('li', null, 'Connect to your Twitch channel'),
            React.createElement('li', null, 'Optional: Set a starting level (1-100)'),
            React.createElement('li', null, 'Chat sends commands: ', React.createElement('strong', null, 'w'), ', ', React.createElement('strong', null, 'a'), ', ', React.createElement('strong', null, 's'), ', ', React.createElement('strong', null, 'd')),
            React.createElement('li', null, 'Navigate from the ', React.createElement('span', { style: { color: '#00ff88' } }, 'green start'), ' to the ', React.createElement('span', { style: { color: '#ff0088' } }, 'pink exit')),
            React.createElement('li', null, 'Each level increases maze complexity'),
            React.createElement('li', null, 'All commands are queued and executed in order')
          )
        )
      );
    }

    ReactDOM.render(React.createElement(MazeCrawl), document.getElementById('root'));
  </script>
</body>
</html>